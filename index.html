<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flood Alert ‚Äî Trivandrum (Enhanced)</title>

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet plugins -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet.locatecontrol/dist/L.Control.Locate.min.css" />
  <script src="https://unpkg.com/leaflet.locatecontrol/dist/L.Control.Locate.min.js"></script>

  <script src="https://unpkg.com/leaflet-ant-path@1.6.0/dist/leaflet-ant-path.min.js"></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.js"></script>

  <style>
    :root{
      --card-bg: rgba(255,255,255,0.95);
      --accent-1: linear-gradient(135deg,#2dd4bf,#06b6d4);
      --accent-2: linear-gradient(135deg,#7c3aed,#ef4444);
      --glass: rgba(255,255,255,0.6);
      --shadow: 0 8px 30px rgba(11,22,39,0.15);
    }
    html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#e6f7fb 0%, #f7fbff 100%)}
    #map{height:100vh;width:100vw;}

    /* Controls card */
    .controls{
      position: absolute;z-index:1400;left:14px;top:14px;width:340px;padding:16px;border-radius:14px;background:var(--card-bg);box-shadow:var(--shadow);backdrop-filter: blur(6px);
      transition: transform .25s ease, box-shadow .25s ease;
    }
    .controls:hover{transform: translateY(-4px)}
    .controls h2{margin:0 0 8px;font-size:16px}
    .row{display:flex;gap:8px}
    .field{flex:1}
    input[type="search"],button{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(10,10,10,0.06);font-size:14px}
    .muted{font-size:13px;color:#475569;margin-top:8px}
    .infoBox{margin-top:10px;padding:10px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.8),rgba(255,255,255,0.6));font-size:13px}

    /* small footer */
    .small{font-size:12px;color:#334155;margin-top:8px}

    /* animated legend */
    .legend{position:absolute;right:14px;top:14px;z-index:1400;padding:12px;border-radius:12px;background:var(--card-bg);box-shadow:var(--shadow);width:220px}
    .legend .item{display:flex;align-items:center;gap:8px;margin-bottom:8px}
    .dot{width:14px;height:14px;border-radius:50%;}
    .line-sample{height:8px;border-radius:6px;width:42px}

    /* responsive */
    @media (max-width:420px){.controls{width:92%;left:4%;top:8px;padding:12px}}
  </style>
</head>
<body>

<div class="controls" id="controls">
  <h2>Flood-aware Navigation ‚Äî Trivandrum</h2>

  <div class="row">
    <div class="field">
      <label for="startSearch">Start (type & press enter)</label>
      <input id="startSearch" type="search" placeholder="Current location or address" />
    </div>
    <div style="width:44px;display:flex;align-items:flex-end">
      <button id="useCurrent" title="Use current location">üìç</button>
    </div>
  </div>

  <div style="margin-top:8px;">
    <label for="endSearch">Destination (type & press enter)</label>
    <input id="endSearch" type="search" placeholder="Destination address or place" />
  </div>

  <div style="display:flex;gap:8px;margin-top:10px">
    <button id="goBtn">Get Route</button>
    <button id="clearBtn" style="background:transparent;border:1px solid rgba(0,0,0,0.06)">Clear</button>
  </div>

  <div class="infoBox" id="info">No route yet ‚Äî type start and destination.</div>
  <div class="small">Weather: <span id="weather">‚Äî</span></div>
  <div class="muted">Pro tip: Press Enter after typing a place. Use the üìç button to snap to your live location. Map is restricted to Trivandrum.</div>
</div>

<div class="legend" id="legend">
  <div style="font-weight:600;margin-bottom:8px">Map Legend</div>
  <div class="item"><div class="dot" style="background:linear-gradient(90deg,#06b6d4,#2dd4bf)"></div><div>Live user location</div></div>
  <div class="item"><div class="line-sample" style="background:linear-gradient(90deg,#3b82f6,#06b6d4)"></div><div>Primary route</div></div>
  <div class="item"><div class="line-sample" style="background:linear-gradient(90deg,#10b981,#34d399);height:8px;border:2px dashed rgba(0,0,0,0.06)"></div><div>Alternate route (avoiding flood)</div></div>
  <div class="item"><div class="dot" style="background:#ef4444"></div><div>Flooded segment</div></div>
</div>

<div id="map"></div>

<script>
  // ---------------------------
  // === CONFIG & KEYS ========
  // ---------------------------
  const OPENROUTESERVICE_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImViOTBkMjI4ZGUyNDRkMzg5MGU1ZWVkNjU0MDU0Y2MzIiwiaCI6Im11cm11cjY0In0=';
  const OPENWEATHER_KEY = 'ce70bf8bdb2bbf3ad192ee196735d6cf';

  // Trivandrum bounding box (tight)
  const trivandrumBounds = L.latLngBounds([8.30, 76.70], [8.72, 77.12]);

  // Create map
  const map = L.map('map', {
    maxBounds: trivandrumBounds,
    maxBoundsViscosity: 1.0,
    minZoom: 11,
    maxZoom: 17
  }).setView([8.52, 76.94], 12.5);

  // Tiles (OSM)
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // locate control (provides a button too)
  L.control.locate({keepCurrentZoomLevel:true,showPopup:false}).addTo(map);

  // markers and layers
  let userMarker = null;
  let userAccuracy = null;
  let routeLayer = null;
  let altRouteLayer = null;
  let floodLayer = null;
  let startArrow = null;
  let endMarker = null;

  // custom icons
  const userIcon = L.circleMarker([0,0],{radius:8,color:'#fff',weight:2,fillColor:'#06b6d4',fillOpacity:1}).options;

  const endIcon = L.divIcon({className:'end-icon',html:'<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="8" fill="#ef4444"/><circle cx="12" cy="12" r="4" fill="#fff"/></svg>',iconSize:[24,24],iconAnchor:[12,12]});

  // keep user's marker always visible and follow updates
  function onLocationFound(lat,lng,accuracy){
    const latlng = [lat,lng];
    if(!userMarker){
      userMarker = L.marker(latlng,{title:'You',riseOnHover:true}).addTo(map).bindPopup('You are here');
    } else {
      userMarker.setLatLng(latlng);
    }
    if(!userAccuracy){
      userAccuracy = L.circle(latlng,{radius:Math.max(accuracy,8),color:'#06b6d4',fillOpacity:0.08}).addTo(map);
    } else {
      userAccuracy.setLatLng(latlng).setRadius(Math.max(accuracy,8));
    }
  }

  // Watch position (live)
  if(navigator.geolocation){
    navigator.geolocation.getCurrentPosition(pos=>{
      onLocationFound(pos.coords.latitude,pos.coords.longitude,pos.coords.accuracy);
    },err=>console.warn('geolocate init err',err),{enableHighAccuracy:true});

    navigator.geolocation.watchPosition(pos=>{
      onLocationFound(pos.coords.latitude,pos.coords.longitude,pos.coords.accuracy);
    },err=>console.warn('geolocate watch err',err),{enableHighAccuracy:true,maximumAge:3000,timeout:10000});
  } else {console.warn('geolocation not supported')}

  // Simple Nominatim search, returns first 8 results
  async function geocode(query){
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&addressdetails=1&limit=8`;
    const res = await fetch(url,{headers:{'Accept':'application/json','User-Agent':'FloodAlert/1.0'}});
    if(!res.ok) throw new Error('Geocode failed');
    const data = await res.json();
    return data; // array
  }

  // UI elements
  const startInput = document.getElementById('startSearch');
  const endInput = document.getElementById('endSearch');
  const goBtn = document.getElementById('goBtn');
  const clearBtn = document.getElementById('clearBtn');
  const useCurrentBtn = document.getElementById('useCurrent');
  const infoBox = document.getElementById('info');
  const weatherBox = document.getElementById('weather');

  // convenience storage
  let startCoord = null; // [lat, lng]
  let endCoord = null;

  // allow Enter key to trigger search & suggestion
  function handleEnter(e, which){
    if(e.key === 'Enter'){
      const q = e.target.value.trim();
      if(!q) return;
      geocode(q).then(results=>{
        if(results.length===0) return alert('No places found');
        // pick first match
        const r = results[0];
        const lat = parseFloat(r.lat); const lon = parseFloat(r.lon);
        if(which==='start'){
          startCoord = [lat,lon];
          startInput.value = r.display_name;
          L.marker([lat,lon]).addTo(map).bindPopup('Start: '+r.display_name).openPopup();
          map.setView([lat,lon],13);
        } else {
          endCoord = [lat,lon];
          endInput.value = r.display_name;
          L.marker([lat,lon]).addTo(map).bindPopup('Destination: '+r.display_name).openPopup();
          map.setView([lat,lon],13);
        }
      }).catch(err=>{console.error(err);alert('Search failed')});
    }
  }
  startInput.addEventListener('keydown',e=>handleEnter(e,'start'));
  endInput.addEventListener('keydown',e=>handleEnter(e,'end'));

  useCurrentBtn.addEventListener('click',()=>{
    if(userMarker){
      const latlng = userMarker.getLatLng();
      startCoord = [latlng.lat,latlng.lng];
      startInput.value = 'Current location';
      map.setView(latlng,13);
      userMarker.openPopup();
    } else { alert('Waiting for location ‚Äî allow location permissions.') }
  });

  clearBtn.addEventListener('click',()=>{
    startInput.value='';endInput.value='';startCoord=null;endCoord=null;infoBox.innerHTML='Cleared.';
    if(routeLayer){map.removeLayer(routeLayer);routeLayer=null}
    if(altRouteLayer){map.removeLayer(altRouteLayer);altRouteLayer=null}
    if(floodLayer){map.removeLayer(floodLayer);floodLayer=null}
    if(startArrow){map.removeLayer(startArrow);startArrow=null}
    if(endMarker){map.removeLayer(endMarker);endMarker=null}
    weatherBox.innerText='‚Äî';
  });

  // Compute route using OpenRouteService (driving-car)
  async function getRoute(coords){
    const url = 'https://api.openrouteservice.org/v2/directions/driving-car/geojson';
    const body = {coordinates: coords};
    const res = await fetch(url,{method:'POST',headers:{'Authorization':OPENROUTESERVICE_KEY,'Content-Type':'application/json'},body:JSON.stringify(body)});
    if(!res.ok) throw new Error('ORS route failed');
    const data = await res.json();
    return data;
  }

  // draw route and decorations
  function drawRoute(coordinates){ // coords array of [lat,lng]
    if(routeLayer) map.removeLayer(routeLayer);
    routeLayer = L.polyline(coordinates,{weight:6,opacity:0.95}).addTo(map);

    // animated ant path on top
    L.antPath(coordinates,{delay:400,paused:false,hardwareAccelerated:true}).addTo(map);

    // decorate with arrows using polylineDecorator
    if(startArrow) map.removeLayer(startArrow);
    startArrow = L.polylineDecorator(routeLayer,{
      patterns:[{offset:0,repeat:0, symbol:L.Symbol.arrowHead({pixelSize:16,polygon:false,pathOptions:{stroke:true, color:'#0ea5a4',weight:2}})}]
    }).addTo(map);

    map.fitBounds(routeLayer.getBounds(),{padding:[60,60]});
  }

  function drawAltRoute(coordinates){
    if(altRouteLayer) map.removeLayer(altRouteLayer);
    altRouteLayer = L.polyline(coordinates,{weight:5,opacity:0.9,dashArray:'10,8'}).addTo(map);
  }

  function drawFlood(segment){
    if(floodLayer) map.removeLayer(floodLayer);
    floodLayer = L.polyline(segment,{color:'#ef4444',weight:8,opacity:0.95,dashArray:'6,8'}).addTo(map);
  }

  // fetch weather for lat/lng
  async function fetchWeather(lat,lng){
    try{
      const r = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=${OPENWEATHER_KEY}&units=metric`);
      if(!r.ok) throw new Error('weather failed');
      const d = await r.json();
      weatherBox.innerText = `${d.weather[0].description}, ${d.main.temp}¬∞C`;
    }catch(e){console.warn(e);weatherBox.innerText='‚Äî'}
  }

  // main route flow
  goBtn.addEventListener('click',async ()=>{
    try{
      // accept either typed geocoded coords or 'Current location'
      if(startInput.value.trim().toLowerCase()==='current location' && userMarker){
        const p = userMarker.getLatLng(); startCoord=[p.lat,p.lng];
      }
      if(!startCoord){
        // attempt geocode the typed string
        if(startInput.value.trim()){
          const res = await geocode(startInput.value.trim());
          if(res.length===0) return alert('Start place not found');
          startCoord=[parseFloat(res[0].lat),parseFloat(res[0].lon)];
        } else return alert('Add a start location');
      }
      if(!endCoord){
        if(endInput.value.trim()){
          const res = await geocode(endInput.value.trim());
          if(res.length===0) return alert('End place not found');
          endCoord=[parseFloat(res[0].lat),parseFloat(res[0].lon)];
        } else return alert('Add a destination');
      }

      infoBox.innerHTML='Calculating route...';

      // ORS needs coords in [lng,lat]
      const orsCoords = [[startCoord[1],startCoord[0]],[endCoord[1],endCoord[0]]];
      const routeData = await getRoute(orsCoords);

      const coords = routeData.features[0].geometry.coordinates.map(c=>[c[1],c[0]]);
      drawRoute(coords);

      // show start arrow & end marker
      if(endMarker) map.removeLayer(endMarker);
      endMarker = L.marker(endCoord,endIcon).addTo(map).bindPopup('Destination').openPopup();

      // compute summary
      const summary = routeData.features[0].properties.summary;
      const distanceKm = (summary.distance/1000).toFixed(2);
      const durationMin = (summary.duration/60).toFixed(1);
      const avgSpeed = ((summary.distance/summary.duration)*3.6).toFixed(1);
      infoBox.innerHTML = `<strong>Distance:</strong> ${distanceKm} km<br><strong>Duration:</strong> ${durationMin} min<br><strong>Avg speed:</strong> ${avgSpeed} km/h`;

      // fetch weather at start
      fetchWeather(startCoord[0],startCoord[1]);

      // simulate flood segment as a mid-segment of route (replace with real flood geometry if available)
      const mid = Math.floor(coords.length/2);
      const floodSegment = coords.slice(Math.max(0,mid-3),Math.min(coords.length,mid+3));
      drawFlood(floodSegment);

      // build an avoid polygon for ORS: use floodSegment reversed into [lng,lat]
      const polyCoords = floodSegment.map(c=>[c[1],c[0]]);
      // duplicate first at end to close polygon (small buffer):
      if(polyCoords.length>2) polyCoords.push(polyCoords[0]);

      // request alternative route avoiding the flood polygon
      try{
        const altBody = {coordinates: [[startCoord[1],startCoord[0]],[endCoord[1],endCoord[0]]],avoid_polygons:{type:'Polygon',coordinates:[polyCoords]}};
        const altRes = await fetch('https://api.openrouteservice.org/v2/directions/driving-car/geojson',{method:'POST',headers:{'Authorization':OPENROUTESERVICE_KEY,'Content-Type':'application/json'},body:JSON.stringify(altBody)});
        if(altRes.ok){
          const altData = await altRes.json();
          const altCoords = altData.features[0].geometry.coordinates.map(c=>[c[1],c[0]]);
          drawAltRoute(altCoords);
        } else {
          console.warn('Alt route not returned',await altRes.text());
        }
      }catch(e){console.warn('Alt route failed',e)}

    }catch(e){console.error(e);alert('Route failed: '+(e.message||e))}
  });

  // prevent zooming/panning out of trivandrum bounds by listening to moveend
  map.on('moveend',()=>{
    if(!trivandrumBounds.contains(map.getCenter())){
      // snap back to bounds
      map.panInsideBounds(trivandrumBounds,{animate:true});
    }
  });

  // keep user's location always visible by listening to position updates
  setInterval(()=>{
    if(userMarker){
      const latlng = userMarker.getLatLng();
      // small auto-pan if user is close to edge
      const px = map.latLngToContainerPoint(latlng);
      const w = map.getSize();
      if(px.x<80||px.x>w.x-80||px.y<80||px.y>w.y-80){
        map.panTo(latlng,{animate:true});
      }
    }
  },3500);

  // initial attribution & tips
  infoBox.innerHTML='Ready ‚Äî type a start and destination, or press üìç to use your current location.';

</script>

</body>
</html>
